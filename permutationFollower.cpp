#include<iostream>
#include<cstdint>
#include<chrono>

int main(int argc, char* argv[]) {
    uint64_t iterations;
    char* t = nullptr;
    if (argc != 2 || (iterations = strtoull(argv[1], &t, 10)) == 0 || errno) {
        std::cerr << "Reads from stdin a permutation with one cycle generated by permutationGenerator.\n"
            << "Exactly one parameter must be passed, iter: a nonnegative nonzero integer.\n"
            << "'Follows' the permutation n times. Time to follow the permutation is recorded.\n"
            << "For each cycle, a line is printed with two tab separated values. First total time, second average time per follow operation.\n";
        return 1;
    }

    using clk = std::chrono::high_resolution_clock;
    using dur = std::chrono::duration<double>;
    auto beg = clk::now();

    //get array
    uint64_t size;
    std::cin.read(reinterpret_cast<char*>(&size), sizeof(uint64_t));
    beg = clk::now();
    uint64_t *arr = new uint64_t[size];
    std::cerr << "Allocating arr of size " << size << " took " << dur(clk::now() - beg).count() << " seconds" << std::endl;
    beg = clk::now();
    std::cin.read(reinterpret_cast<char*>(arr), sizeof(uint64_t)*size);
    std::cerr << "Reading arr of size " << size << " took " << dur(clk::now() - beg).count() << " seconds" << std::endl;

    /*
    std::cerr << size << std::endl;
    for (uint64_t i = 0; i < size; ++i)
        std::cerr << arr[i] << '\t';
    std::cerr << std::endl;
    */

    //verify
    beg = clk::now();
    double temp;
    uint64_t ind = 0, jumps = 0;
    do {
        ind = arr[ind];
        ++jumps;
    } while (ind && jumps <= size);
    if (jumps != size) {
        std::cerr << "Read permutation is not a cycle of length " << size << "!\n";
        return 1;
    }
    std::cerr << "Verifying read permutation is a cycle of length one took " << (temp = dur(clk::now() - beg).count()) << " seconds."
       << " Average jump of " << (temp/size)*1e9 << " nanoseconds.\n";

    //test
    double* times = new double[iterations];

    for (uint64_t i = 0; i < iterations; ++i) {
        beg = clk::now();
        volatile uint64_t ind = 0;
        do {
            ind = arr[ind];
        } while (ind);
        times[i] = dur(clk::now() - beg).count();
        std::cout << size << "_run" << i+1 << '\t' << times[i] << '\t' << (times[i]/size)*1e9 << '\n';
    }

    //output results
    //for (uint64_t i = 0; i < iterations; ++i)
        //std::cout << times[i] << '\t' << times[i]/size << '\n';

    return 0;
}
